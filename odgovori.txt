1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were
   delivered to the same handler, what feature that exists in the current implementation could not be provided?)

 - Da nemamo individualne handlere za iznimke/interrupte, ne bi bili u mogućnosti da znamo šta je generisalo iznimku.
   Pri svakom pozivu handlera, na stack se ubaci i odgovarajući broj koji odgovara kodu iznimke/interrupt-a, kako bi
   znali šta je generisalo iznimku/interrupt i bili u mogućnosti da pozovemo odgovarajući handler u trap() funkciji.

2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general
   protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the
   kernel actually allows softint's int $14 instruction to invoke the 0 kernel's page fault handler (which is interrupt vector 14)?

 - Nije bilo potrebe za modifikacijama koda od programa softint. Kod od programa softint se izvršava pod nivoom
   privilegija 3 (DPL = 3), dok je pristup bilo kojem od GATE-a vezanom iznimke (osim breakpoint iznimke) dozvoljen
   programu koji se izvršava pod nivoom privilegija 0 (DPL = 0), odnosno kernel kodu. Kada bi dozvolili programima
   da koriste int $14 instrukciju, onda bi svaki program mogao sam od sebe genrirat General Protection Fault iznimku,
   što niko drugi osim hardvera ne treba da generira (u tom slučaju bi sigurnost OS-a bila narušena).

3. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized
   the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the
   breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

 - Kao što je već navedeno u prethodnom odgovoru, korisnički programi se izvršavaju pod nivoom privilegija 3 (DPL = 3).
   Pristup GATE-u od bilo koje hardverske iznimke je dozvoljen samo programu koji se izvršava pod nivoom privilegija 0
   (DPL = 3), odnosno kernel kodu. Da bi korisnički program mogao generirati breakpoint iznimku, potrebno je u pozivu
   SETGATE za iznimku breakpoint specificirati nivo privilegija 3, u suprotnom bi se generirala iznimka General Protection
   Fault, odnosno pokušaj pristupa kodu koji zahtijeva više privilegije bi bio zabranjen.

4. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?

 - Sigurnost, na prvom mjestu. Kada bi softint mogao generirati iznimke sam od sebe, mogao bi potencijalno narušiti
   sigurnost drugog programa koji se trenutno izvršava, ili potencijalno ubaciti maliciozni kod na stek, koji bi
   loše programiran kernel mogao izvršiti i time obezbijediti običnom programu pristup kernel kodu.
