1. Assuming that the following JOS kernel code is correct, what type should variable x have,
   uintptr_t or physaddr_t?

	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;

 - Sve adrese u kernelu su virtualne adrese, formirane koristeći segmentiranje i straničenje.
   Fizičke adrese su zapisane samo u PTE-ovima. To znači da je x ustvari pointer na virtuelnu
   adresu, a ne fizičku (iako u ovom slučaju ovako zapisana adresa odgovara istoj fizičkoj
   adresi (PD 0 PT 0 OFFSET 10)).

2. What entries (rows) in the page directory have been filled in at this point? What addresses do
   they map and where do they point? In other words, fill out this table as much as possible:


   Entry 	Base Virtual Address 	Points to (logically):
   1023		0xffc00000		Poslijednja 4 MB označena kao prisutna, ali zasad neiskorištena
   ...
   960		0xf0000000		KERNBASE
   959		0xefc00000		Kernel Stack
   958		0xef800000		ULIM / MMIOBASE (nije eksplicitno mapirana)
   957		0xef400000		UVPT (korisnički dostupan page table direktorij)
   956		0xef000000		UPAGES (korisnički dostupan niz stranica)
   ...
   1		0x00400000		Zasad neiskorištene stranice do Entry-a 959
   0		0x00000000		Označeno kao prazno, kernel učitan u fizičku memoriju koju ovaj PDE opisuje

3. We have placed the kernel and user environment in the same address space. Why will user programs not
   be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

 - Korisnički programi se izvršavaju u najnižem nivou privilegija procesora, gdje je potrebno
   postaviti PTE_U zastavicu na PTE-ove koji mapiraju memoriju koju će koristiti aplikacije.
   PTE-ovi koji mapiraju adresni prostor kernela nemaju uključenu PTE_U zastavicu, pa zbog
   toga korisnički programi neće moći niti čitati iz niti upisivati u taj dio memorije.

4. What is the maximum amount of physical memory that this operating system can support? Why?

 - Maksimalna količina memorije koju ovaj OS može podržati je 4 GB, jer radimo sa 32 bitnim
   procesorom i 32 bitnim adresama, što znači da možemo adresirati prostor u opsegu od [0, 2^32),
   odnosno od 0 do 4 GB.

5. How much space overhead is there for managing memory, if we actually had the maximum amount of
   physical memory? How is this overhead broken down?

 - Imamo na raspolaganju 1024 PDE-a, svaki sastavljen od 32 bita (4 bajta). Za mapiranje svih
   1024 PDE-a potrebno je 4 KB memorije. Svaki PDE ima 1024 PTE-a od po 4 bajta, što znači
   da za svaki direktorij je dodatno potrebno 4 KB za mapiranje svih page tabela. Za mapiranje
   kompletnog adresnog prostora bi nam trebalo 4 KB za sve PDE-ove, te dodatnih 4 MB za sve
   PTE-ove (4 KB PTE/PD * 1024 PD). Uštede na prostoru bi se mogle dobiti korištenjem fizičkih
   stranica od po 4 MB, što bi značilo da je PDE ujedno i PTE, te bi nam za to trebalo samo 4 KB
   memorije.

6. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on
   paging, EIP is still a low number (a little over 1MB). At what point do we transition to running
   at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between
   when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition
   necessary?

 - entrypgdir.c mapira logičke adrese [0, 4 MB) i adrese [KERNBASE, KERNBASE + 4 MB) u isti fizički
   prostor od 0 do 4 MB. Korištenjem niže adrese u ovom slučaju je ekvivalentno korištenju adrese
   u prostoru iznad KERNBASE, baš zbog dijeljenja istog fizičkog prostora. Tranzicija u izvršavanje
   koda na višim adresama je potrebna baš zbog toga što su adrese podešene u odnosu na KERNBASE, ali
   i zbog toga što se na kraju podešavanja paging-a, virtuelni prostor [0, 4 MB) označi kao empty.
